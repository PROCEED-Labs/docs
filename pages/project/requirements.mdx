## Vision to Goals

see
[vision](/vision/vision),
[goals](/vision/goals),

=> why did PROCEED choose exactly this goals?

| Vision                   | Goal                            |
| ------------------------ | ------------------------------- |
| Individual Processes     | Context-aware Processes         |
|                          | Privacy-aware Processes         |
| Interoperable Processes  | Interoperable Processes         |
|                          | Enterprise-aware Processes      |
|                          | Portable Processes              |
| IoT-ready Processes      | IoT Integration                 |
|                          | P2P Processes                   |
|                          | Fog Processes                   |
|                          | Context-aware Processes         |
| Resilient Execution      | P2P Processes                   |
|                          | Portable Processes              |
|                          | Interoperable Processes         |
|                          | Fog Processes                   |
| Customer Privacy         | Privacy-aware Processes         |
|                          | Fog Processes                   |
|                          | P2P Processes                   |
| Easy process development | Smart Process Development Suite |

{/*

## Goals to Features

| Goal                       | Feature       |
| -------------------------- | ------------- |
| Offline Processes          | Smart Routing |
|                            |               |
| Portable Processes         | Smart Routing |
|                            | Capability    |
| IoT Integration            |               |
|                            |               |
| Context-aware Processes    |               |
|                            |               |
| Privacy-aware Processes    |               |
|                            |               |
| Enterprise-aware Processes |               |
|                            |               |
| Interoperable Processes    |               |

*/}

## IoT Device Communication

Low Power Wide Area Network (LPWAN):

- high distance network coverage, robust communication, it security, low power consumption, small costs
- high Bandwidth is not important
- Technologies:
  - Narrowband (NB-)IoT:
    - Open, Extension of LTE standard (LET Cat-NB1, LTE Cat-M1)
    - LTE Basisstationen fundamentally support this standard with their hardware, just software update
    - spare communication,
    - small bandwith (180 kHz, max. 150 - 250 kBit/s)
    - latenz: < 10s (better than other LPWAN)
    - world-wide roaming
    - one receiving antenna
    - cheapter receiver than normal LTE, because there is way less functionality needed, e.g. transmit power regulation, easy channel coding (QPSK)
    - possible LTE "Power Saving Mode" up to 310h, but the whole time connected to the cellular network
    - LTE security: USIM (Auth and Auto), End-to-end encryption
    - eSIM: change of operators wireless
  - LoRaWAN
  - UNB/Sigfox

## Requirements

- die Engine sollte Standard-BPMN-Diagramme ausführen können
- möglichst keine "Hersteller"-abhängigen Erweiterungen
- die Sensoren und Aktoren von IoT-Geräten sollen im BPMN-Diagramm eingebunden werden können
- IoT-Geräten sollen die Fähigkeiten ihrer Sensoren und Aktoren auf Anfrage veröffentlichen
- sollte auf so vielen wie möglichen Geräten/OS ausführbar sein. Mindestens: Win, Linux, Mac, Android, IOS, Raspberry; Optional: Amazon Echo, Google Chromecast, Amazon FireTV, AppleTV, Smart TV OSs, Smart Watch Oss, Android Wear, RTOS (z.B. einem Drohnenbetriebssystem), ARM-basierte und stark beschränkte Systeme
- Architektur muss leicht erweiterbar und wartbar sein, da nur wenig ständige Projekt-Mitarbeiter (einheitlicher Tech-Stack, nicht zu viele unterschiedliche Varianten)
- da viele Funktionalitäten _unabhängig_ in Abschlussarbeiten und Seminaren (und eventuell durch Open Source Comm.) entwickelt werden (Problem: schwierige Kommunikation), muss ein passender Entwicklungsworkflow etabliert werden. Z.B. könnte ein dynamisches Laden von Komponenten (Plugin-System) über die Aktivierung mittels einer Konfig-Datei sinnvoll oder Feature Toggles oder Feature Branches,
- Beispiele für iterativ hinzugefügte Funktionalitäten: Logging-/Health-System, Komm. über unterschiedliche Protokolle, Geräte-Beschränkungs-Mgmt, Security, Capability-Modul, Gesamt-Prozess-Weitergabe zur Laufzeit
- da nicht für jedes proprietäre OS eine Anwendung geschrieben werden kann, muss die Architektur Micro-Service basiert sein. D.h. es müssen standardisierte Web-Schnittstellen zw. den Micro-Services definiert sein, damit:
  - einzelne Micro-Services ausgelagert werden können, z.B.
    - die IoT-Dienste von stark beschränkten Geräten
    - die Tasklist auf in jedem Browser dargestellt werden kann
- Hersteller für einzelne Micro-Services auch ihre eigene Implementierung bereitstellen können
- im Hinblick auf die dynamische Weitergabe von Prozessen ist es wichtig, dass Unternehmen Beschränkungen an ihren Geräten definieren können. Z.B. könnten folgende Elemente beschränkt werden: welche BPMN-Elemente (z.B. keine Service Tasks), für Script-Tasks: ob externe Libs verwendet werden dürfen und wenn ja: welche, ob ext. Libs dyn. geladen werden können (aus einem internen Lib-Repo (Maven), ob I/O und Netzwerk-Operationen erlaubt sind, etc.
- mögliche Lösungen: "Constraint Profiles", Docker, 'vm'-Lib in Node.js, Web-Laufzeitumgebung
