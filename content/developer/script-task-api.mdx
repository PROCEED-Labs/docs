import { Callout } from 'nextra/components';

# BPMN Script Tasks

An executable BPMN diagram can contain Script Tasks.
In PROCEED, you can use Blockly or pure JavaScript (JS) to create an executable Script Task.
The programming in Blockly is limited to the usage of the predefined blocks which resemble many JavaScript possibilities.
The programming in JavaScript is more versatile but -- compared to Blockly -- for advanced Users.

The code of a script task is executed within a sandboxed JavaScript environment, so that it is not able to influence the PROCEED Engine, the Operation System or other process instances.

The following page describes the available JavaScript possibilities and libraries usable in Script Tasks.

## JavaScript and PROCEED Libraries

A Script Task can be defined with pure JavaScript. Currently PROCEED supports the **ECMAScript 2020** version.
Moreover, there are several library functions that can be used for accessing global data, process variables or to trigger network requests.

### Ending Scripts: optional `return` and `Error`

Scripts can end without a `return` statement.
Optionally, it can also end with `return`.
In this case, you should only return an `Object`.
Its properties (_key_ and _value_) will write and update the process variables.

A Script Task can also end by a semantic error, which will be
caught by an attached boundary _Error_ or _Escalation_ event. This is done by
throwing an `BpmnError` or an `BpmnEscalation`.

If an error is thrown but not caught within the BPMN process, or if the script
itself has an error (e.g. syntax error), the token will end its execution.
(This only stops the running token, not the whole process.)

### Example

The following example is a BPMN process describing the workflow of an online
shop which offers to ship products to their customers: The process starts with a
received order, then the order gets processed and finally shipped to a customer.

Using the attached boundary elements _Error_ and _Escalation_, the process can
handle exceptional behavior when processing the order: If there is an escalation
triggered because of an unusual high amount of ordered products, the customer
will be informed of a late shipment. If there occurs an error while processing,
the customer is informed that the order got canceled.

![BPMN Order Process](/images/bpmn/BPMN_Boundary_Process.png)

#### Example Script Code

```js
const amount = variable.get('amount'); // amount of the ordered products
const cost = variable.get('cost'); // cost of the ordered products

if (cost < 50) {
  // update the costs
  try {
    // add shipping costs to total cost
    variable.set('cost', cost + 5);
  } catch (err) {
    log.info('Error occured while processing order: ' + err);
    throw new BpmnError('A severe error occured while processing');
  }
}

if (amount > 100) {
  // execute alternative flow to the attached escalation boundary-event
  throw new BpmnEscalation('late shipment', 'The order is too much');
}
```

## PROCEED Library: Script API

### `variable`

In a Script Task it is possible to read and modify data of the _process_.
This can be done with the object `variable`.
It is recommended to predefine process variables in the _Automation_ tab of the _Property Panel_ before using them inside a Script Task.

<Callout type='info'>
  Of course, it is also possible to use JS' capability to define variables with `let, const, var`. These variables are
  only local to the Script Task and will be deleted after its execution.
</Callout>

When setting _process_ variables, use the serializable JSON _data types_: `string`, `number`, `boolean`, `object`, `array`.
Functions or cyclical objects are automatically converted to `undefined`.

Process variables usually exist in two different scopes: inside the Script Task (_local_) and _outside_ the Script Task on the level of the entire process.
At the start of each Script Task, the process variables are once copied into the local scope of the task.
After the Script Task execution ended, the local process variables automatically update (override) the process variables outside of the task.

<Callout type='warning'>
  Although we recommend to usually read and write in the local scope, there are also methods for accessing the outside
  scope. But keep in mind that writing into the outside scope can lead to concurrency problem if other (parallel) tasks
  also write into these process variables at the same time.
</Callout>

| API                                       | Access to the process variables.                                                                                                            |
| ----------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| `.get( "<var-name>" )`                    | Returns the value of a variable from the local scope.                                                                                       |
| `.getGlobal( "<var-name>" )`              | Returns the value of a variable from the global scope.                                                                                      |
| `.getAll()`                               | Returns an object containing all local variables and their values.                                                                          |
| `.getAllGlobal()`                         | Returns an object containing all global variables and their values.                                                                         |
| `.getWithLogs()`                          | Returns an object containing all local variables, their values and their log (array) about the modification time points.                    |
| `.getWithLogsGlobal()`                    | Returns an object containing all global variables, their values and their log (array) about the modification time points plus the modifier. |
| `.set( "<var-name>", <var-value> )`       | Updates the value of a local variable.                                                                                                      |
| `.setGlobal( "<var-name>", <var-value> )` | Updates the value of a global process variable.                                                                                             |

**Example Code**

```js
log.info("\nget('var1'): " + variable.get('var1'));
log.info("\ngetGlobal('var1'): " + variable.getGlobal('var1'));
log.info('\ngetAll(): ' + JSON.stringify(variable.getAll(), null, 2));
log.info('\ngetAllGlobal(): ' + JSON.stringify(variable.getAllGlobal(), null, 2));
log.info('\ngetWithLogs(): ' + JSON.stringify(variable.getWithLogs(), null, 2));
log.info('\ngetWithLogsGlobal(): ' + JSON.stringify(variable.getWithLogsGlobal(), null, 2));

variable.set('var1', 123);

log.info("\nget('var1'): " + variable.get('var1'));
log.info("\ngetGlobal('var1'): " + variable.getGlobal('var1'));
log.info('\ngetAll(): ' + JSON.stringify(variable.getAll(), null, 2));
log.info('\ngetAllGlobal(): ' + JSON.stringify(variable.getAllGlobal(), null, 2));
log.info('\ngetWithLogs(): ' + JSON.stringify(variable.getWithLogs(), null, 2));
log.info('\ngetWithLogsGlobal(): ' + JSON.stringify(variable.getWithLogsGlobal(), null, 2));

variable.setGlobal('var1', 456);

log.info("\nget('var1'): " + variable.get('var1'));
log.info("\ngetGlobal('var1'): " + variable.getGlobal('var1'));
log.info('\ngetAll(): ' + JSON.stringify(variable.getAll(), null, 2));
log.info('\ngetAllGlobal(): ' + JSON.stringify(variable.getAllGlobal(), null, 2));
log.info('\ngetWithLogs(): ' + JSON.stringify(variable.getWithLogs(), null, 2));
log.info('\ngetWithLogsGlobal(): ' + JSON.stringify(variable.getWithLogsGlobal(), null, 2));
```

### `log`

Logging in the PROCEED Engine can be done via the object `log`. Depending on the
log level and the Engine configuration, the logged message will maybe shown in
the console.

| API                     | Write a message to the logging system of the Engine.                 |
| ----------------------- | -------------------------------------------------------------------- |
| `.trace( "<message>" )` | Logging with timestamp in log level _trace_ (deactivated by default) |
| `.debug( "<message>" )` | Logging with timestamp in log level _debug_ (deactivated by default) |
| `.info( "<message>" )`  | Logging with timestamp in log level _info_                           |
| `.warn( "<message>" )`  | Logging with timestamp in log level _warn_                           |
| `.error( "<message>" )` | Logging with timestamp in log level _error_                          |

**Example Code**

```js
log.trace('Hello PROCEED - trace()');
log.debug('Hello PROCEED - debug()');
log.info('Hello PROCEED - info()');
log.warn('Hello PROCEED - warn()');
log.error('Hello PROCEED - error()');
```

### `console`

Logging can also done via the object `console`.
Using this way, the message _will be redirected_ to the logging system of the engine and is essentially nearly the same as the logging functions.
`console` just supports a few other functions:

| API                     | Write a message to the logging system of the Engine.                       |
| ----------------------- | -------------------------------------------------------------------------- |
| `.log( "<message>" )`   | Logging without timestamp.                                                 |
| `.trace( "<message>" )` | Logging with timestamp in log level _trace_ (deactivated by default)       |
| `.debug( "<message>" )` | Logging with timestamp in log level _debug_ (deactivated by default)       |
| `.info( "<message>" )`  | Logging with timestamp in log level _info_                                 |
| `.warn( "<message>" )`  | Logging with timestamp in log level _warn_                                 |
| `.error( "<message>" )` | Logging with timestamp in log level _error_                                |
| `.time( "<label>" )`    | Starts a timer containing label parameter                                  |
| `.timeEnd( "<label>" )` | Ends a timer with given label parameter and displays the result in console |

**Example Code**

```js
console.time('L1');
console.log('Hello PROCEED - log()');
console.trace('Hello PROCEED - trace()');
console.debug('Hello PROCEED - debug()');
console.info('Hello PROCEED - info()');
console.warn('Hello PROCEED - warn()');
console.error('Hello PROCEED - error()');
console.timeEnd('L1');
```

### `wait( <ms> )` [#wait]

A timeout function which pauses/postpones the script execution.
It is synchronous and blocks the execution until the timeout is passed.
_Hint:_ the popular `setTimeout()` is not available in a Script Task.

If the _entire process_ is paused from the Management System, all script code is also paused until the process is resumed. 
If a _pause_ occurs during a `wait()`, the system stores the original expiration time of `wait()`. 
If the process resumes before this original expiration time, the script waits for the remaining time before continuing with the next instructions. 
If the original expiration time has passed after the process resumes, it immediately continues with the next instructions after `wait()`. 

{/* -> uncomment when Bug is solved
**OPEN Bug:** The `wait`function returns an integer: it returns `1` if the process was paused (externally by the MS) during the process execution. Else it returns `0`.
This information is useful since a pausing of the process has an undefined timespan, so the defined _waiting_ time is not reliable anymore.
*/}

| API                              |                                                   |
| -------------------------------- | ------------------------------------------------- |
| `wait(<milliseconds: number>)` | `milliseconds` for pausing the the Script Task execution |

**Example Code**

```js
// log with time:
log.info("Before wait()");
wait(10000); // 10s
log.info("After wait()");
```

{/* -> uncomment when Bug is solved
```js
let hasBeenPaused = wait(10000);
if (hasBeenPaused) {
  log.warn(
    'Attention: wait() has been interrupted by a process pause command (likely triggered by the User in the MS)',
  );
} else {
  log.info('sucessfully waited ');
}
```
*/}

### `waitAsync( <ms> ): Promise` [#wait]

<Callout type='warning'>
  The use of `waitAsync( <ms> ): Promise` is only suitable for advanced users. 
  It makes code execution asynchronous. 
  This allows you to achieve multiple semi-parallel code executions.
</Callout>

Like [`wait()`](#wait) but asynchronous, so it immediately continues with the next code instructions and does not block the specified timeout is finished. 
In this sense, it is similar to the usual `setTimeout()` but only with a Promise. So, you can use `await` or `then()`.
Pausing behavior is the same as for `wait()`.

| API                              |                                                   |
| -------------------------------- | ------------------------------------------------- |
| `waitAsync(<milliseconds: number>): Promise` | `milliseconds` for pausing the the Script Task execution. Returns a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise). |

**Example Code**

```js
 waitAsync(10000).then( () => console.info("Finished waiting 10s") );
```

### `setInterval( <clb>, <ms> )` and `clearInterval( <id> )`

{/*
TODO:
Currently there is a Bug that makes the usage of setInterval synchronous.
If bug is resolved and true asynchronous programming is possible, then include this Warning.

<Callout type='warning'>
  The use of `setInterval()` is only suitable for advanced users. It can make code execution asynchronous. This allows
  you to achieve multiple semi-parallel code executions.
</Callout>

*/}

An interval function which repeatedly calls a _callback_ function (`clb`) after a timeout (`ms`).
It is similar to the conventional `setInterval()` of the Node.js and the Web API.
_Hint:_ the interval timer starts counting after the last interval execution has ended.

The `setInterval()` function returns an _id_ that is used to stop the interval with `clearInterval( <id> )`.
A Script Task can only end when all started intervals have finished.

`setInterval()` is synchronous, i.e. if multiple intervals have been started, one interval execution 
blocks other the code execution of other intervals. 
If you need to run parallel code executions, you currently have to use multiple Script Tasks connected by a parallel Gateway.


{/*
TODO:
Currently there is a Bug that starts the timer for the next interval only after the last execution ended.
If bug is resolved, then include this info.

<Callout type='info'>
  It is important to ensure that code execution duration of your interval is shorter than the interval frequency. Else,
  the timing is quite unreliable. _Hint:_ the interval timer starts counting after the last interval call has ended.
</Callout>
*/}
| API                                                                  |                                                                                                                                     |
| -------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| `setInterval(<clb: function>, <milliseconds: number>): <id: number>` | the `clb` function is repeatly called after the given interval timeout `milliseconds` ended. Return the `id` of the interval timer. |
| `clearInterval( <id: number> )`                                      | stops the interval timer.                                                                                                           |

**Example Code**

```js
let id;
let counter;

let f = function (intervalId, startValue) {
    counter = counter ?? startValue ?? 0;
    counter++;
    log.info('Interval-Id: ' + intervalId + ' Counter: ' + counter);
    if (counter > 5) {
        log.info('Cancel Interval-Id: ' + intervalId);
        clearInterval(intervalId);
    }
};

/* 
Calling setInterval() with a callback function and timeout.
You can directly have function f as the first parameter.
In this case, we put f into another arrow function, because 
id1 is used as the first parameter of f().  
*/
id = setInterval(() => f(id, 2), 1000);
```

### HTTP Network Requests and Server

#### `networkRequest`: sychronous functions

Inside of a Script Task it is possible to send HTTP(S) requests to a given URL.
The prefered way of using `networkRequest` is with its synchronous methods, i.e. the functions wait until an answer is is received.
Since this are network requests, the completion of the methods sometimes need a while until the response is received.

| API                                                                                 | Explanation                                                    |
| ----------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| `.get( "<url>", [<{options}>]): { response, body }`                                 | Sends a GET-Request to a URL                                   |
| `.post( "<url>", <{body}>, ["<content-type>"], [<{options}>]): { response, body } ` | Sends a POST-Request to a URL with a `body` (Object or String) |
| `.put( "<url>", <{body}>, ["<content-type>"], [<{options}>]): { response, body }`   | Sends PUT-Request to URL with a `body` (Object or String)      |
| `.delete( "<url>", [<{options}>]): { response, body }`                              | Sends a DELETE-Request to a URL                                |
| `.head( "<url>", [<{options}>]): { response, body }`                                | Sends a HEAD-Request to a URL                                  |

`"<url>"` is a required parameter defining the endpoint of the network request.
It has the format: `<protocol>://[<user>:<password>@]<address>:[<port>]/[<path>]?[<query>]`
- `<protocol>`: required, needs to be `http` or `https`.
- `[<user>:<password>@]`: optional, used for _Basic_ HTTP authentification (Base64 encoding into `Authorization:` header)
- `<address>` is required and needs to be a DNS domain name or an IP address.
- `[<port>]` and `[<path>]` and `[<query>]` are optional.  
- Example: `"https://user:pass@app.example.com:8000/path/to/resource?compressed=true&limit=10"`

The `["<content-type>"]` is an optional string parameter. Set it to the correct [Mime
type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types)
of the transmitted data. It defaults to `"text/plain"` if body is a string, and
to `"application/json"` if body is a JS object (because it will automatically be
transformed to JSON before sending).

The `[<{options}>]` object is optional.
For unsecured HTTP requests, there are two usable properties: 
- `headers: {}`: An object of strings containing additional request headers.
- `setHost: true|false`: Specifies whether or not to automatically add the `Host` header. Defaults to `true`.

In case of a secure HTTPS connection, the `options` object has some [additional attributes from `https.request`](https://nodejs.org/api/https.html#httpsrequesturl-options-callback).

The network functions only return if the _response_ has a HTTP 2xx status code. The methods return an object that contains two properties: `{ response, body }`

- `response`: is an object that contains meta information about the response,
  including `.headers`, `.httpVersion`, `.method`, `.statusCode`,
  `.statusMessage`, and `.url`. Because it resembles _IncomingMessage_, see the
  [Node.js API about
  IncomingMessage](https://nodejs.org/api/http.html#http_class_http_incomingmessage)
  for more information.
- `body`: Body of the response

The functions throw an [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) if:

- if the response has a **non**-2xx statusCode: `{ response, body }` will be
  returned inside the `Error` object
- if any error is encountered during the request (e.g. DNS resolution, TCP level
  errors, or actual HTTP parse errors)

That's why `try-catch` must be used around network requests.

**Example Code**

```js
try {
  let { response, body } = networkRequest.put(
    'https://localhost:8080/path/to/resource?compressed=true&limit=10',
    {
      api: '2.0',
      data: 'Test data',
      id: 1,
    },
    undefined,
    {
      headers: {
        'X-PROCEED-Example-Header': '33029',
      },
      rejectUnauthorized: false,
    },
  );

  log.info(JSON.stringify(response, null, 2));
  log.info(JSON.stringify(body, null, 2));
} catch (e) {
  log.error('-----------PROBLEM------------');
  log.error(JSON.stringify(e, null, 2));
}
```

#### `networkRequest`: asychronous functions

The network functions are asynchronous, meaning a Promise is returned.
**Attention:** The `async/await` pattern should be used to handle this, **not**
the `.then()` and `.catch()`.

Inside of a Script Task it is possible to send HTTP(S) requests to a given URL.
The prefered way of using `networkRequest` is with its synchronous methods, i.e. the functions wait until an answer is is received.
Since this are network requests, the completion of the methods sometimes need a while until the response is received.

| API                                                                                 | Explanation                                                    |
| ----------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| `.get( "<url>", [<{options}>]): { response, body }`                                 | Sends a GET-Request to a URL                                   |
| `.post( "<url>", <{body}>, ["<content-type>"], [<{options}>]): { response, body } ` | Sends a POST-Request to a URL with a `body` (Object or String) |
| `.put( "<url>", <{body}>, ["<content-type>"], [<{options}>]): { response, body }`   | Sends PUT-Request to URL with a `body` (Object or String)      |
| `.delete( "<url>", [<{options}>]): { response, body }`                              | Sends a DELETE-Request to a URL                                |
| `.head( "<url>", [<{options}>]): { response, body }`                                | Sends a HEAD-Request to a URL                                  |

### Trigger Events

#### `throw new BpmnError( ["<reference>",] "explanation" )`

| API             | Send network requests                                                                                                                                                                                                                                                                                                                                                                           |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `'reference'`   | Optional, a String that is matched to the corresponding `errorCode` of the `error` element (prio 1) or to the `name` attribute of the attached BPMN boundary error event (prio 2). If there is no match but an attached event without a `name`, then the flow is given to this Event. See [Error and Escalation Event description](bpmn-error-escalation#script-and-user-tasks-catching-events) |
| `'explanation'` | A String that is stored in the logging system of the Engine.                                                                                                                                                                                                                                                                                                                                    |

#### `throw new BpmnEscalation( ["<reference>",] "explanation" );`

| API             | Send network requests                                                                                                                                                                                                                                                                                                                                                                                          |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `'reference'`   | Optional, a String that is matched to the corresponding `escalationCode` of the `escalation` element (prio 1) or to the `name` attribute of the attached BPMN boundary escalation event (prio 2). If there is no match but an attached event without a `name`, then the flow is given to this Event. See [Error and Escalation Event description](bpmn-error-escalation#script-and-user-tasks-catching-events) |
| `'explanation'` | A String that is stored in the logging system of the Engine.                                                                                                                                                                                                                                                                                                                                                   |

## Example

```js
const capabilities = getService('capabilities');
const network = getService('network');

await setTimeoutAsync(() => {
  log.info('Script started with a short delay');
}, 5000);

const amount = variable.get('amount');
log.info("The value of the process variable 'amount' is: " + amount);
if (typeof amount === 'number') {
  variable.set('amount', ++amount);
  log.info("Increased variable 'amount' by 1");
} else {
  variable.set('amount', 1);
  log.info("Set variable 'amount' to 1");
}

// send get-request using given url and store response body in variable
try {
  const { response, body } = await network.get('http://localhost:33029/status');
  log.debug(`Successful GET request with response: ${response.statusCode}`);
  log.info(`Engine Status is: ${body}`);
  variable.set('requestedData', body);
} catch (error) {
  if (error.response) {
    log.error('GET Response was not successful. Status Code: ' + error.response.statusCode);
  } else {
    log.error('An error occured in the GET request: ' + error.message);
  }
}

// set current progress of script task to 50%
setProgress(50);

// send put-request using given url and data
const exampleText = '<task>A Simple XML element</task>';
try {
  const { response, body } = await network.put(
    'https://httpbin.org/anything',
    exampleText,
    'text/xml',
    {
      headers: {
        'My-New-Header': 'Sent from PROCEED',
      },
    },
  );
  log.debug(`Successful PUT request with response code: ${response.statusCode}`);
  log.debug(`Successful PUT request with response body: ${body}`);
} catch (error) {
  if (error.response) {
    log.error('PUT Response was not successful. Status Code: ' + error.response.statusCode);
    throw new BpmnEscalation('BAD CODE given back');
  } else {
    log.error('An error occured in the PUT request: ' + error.message);
    throw new BpmnError('An Error 101', 'It seems there is no Server');
  }
}

// check if service is available, return true if so
function checkState() {
  const { response, body } = await network.get('https://exampleservice.org/status');

  if (body.available) {
    log.info('Service is available!');
    return true;
  } else {
    log.info('Service is not available! Test again');
    return false;
  }
}

// request service status every second, end interval if service is available
try {
  await setIntervalAsync(checkState, 1000);
  log.info('Service is available');
} catch (error) {
  if (error.response) {
    log.error('GET Response was not successful. Status Code: ' + error.response.statusCode);
  } else {
    log.error('An error occured in the GET request: ' + error.message);
  }
}

const image = await capabilities.startCapability('takePhoto');

log.info('Photo taken');

// set variable with new value
return { photo: image };
```

![BPMN Network Test Process](/images/bpmn/BPMN_script-task-network.png)
